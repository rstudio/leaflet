{"version":3,"file":"leaflet.markercluster.layersupport-src.js","sources":["src/layersupport.js"],"sourcesContent":["/**\n * Extends the L.MarkerClusterGroup class by mainly overriding methods for\n * addition/removal of layers, so that they can also be directly added/removed\n * from the map later on while still clustering in this group.\n * @type {L.MarkerClusterGroup}\n */\nL.MarkerClusterGroup.LayerSupport = L.MarkerClusterGroup.extend({\n\n\toptions: {\n\t\t// Buffer single addLayer and removeLayer requests for efficiency.\n\t\tsingleAddRemoveBufferDuration: 100 // in ms.\n\t},\n\n\tinitialize: function (options) {\n\t\tL.MarkerClusterGroup.prototype.initialize.call(this, options);\n\n\t\t// Replace the MCG internal featureGroup's so that they directly\n\t\t// access the map add/removal methods, bypassing the switch agent.\n\t\tthis._featureGroup = new _ByPassingFeatureGroup();\n\t\tthis._featureGroup.addEventParent(this);\n\n\t\tthis._nonPointGroup = new _ByPassingFeatureGroup();\n\t\tthis._nonPointGroup.addEventParent(this);\n\n\t\t// Keep track of what should be \"represented\" on map (can be clustered).\n\t\tthis._layers = {};\n\t\tthis._proxyLayerGroups = {};\n\t\tthis._proxyLayerGroupsNeedRemoving = {};\n\n\t\t// Buffer single addLayer and removeLayer requests.\n\t\tthis._singleAddRemoveBuffer = [];\n\t},\n\n\t/**\n\t * Stamps the passed layers as being part of this group, but without adding\n\t * them to the map right now.\n\t * @param layers L.Layer|Array(L.Layer) layer(s) to be stamped.\n\t * @returns {L.MarkerClusterGroup.LayerSupport} this.\n\t */\n\tcheckIn: function (layers) {\n\t\tvar layersArray = this._toArray(layers);\n\n\t\tthis._checkInGetSeparated(layersArray);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Un-stamps the passed layers from being part of this group. It has to\n\t * remove them from map (if they are) since they will no longer cluster.\n\t * @param layers L.Layer|Array(L.Layer) layer(s) to be un-stamped.\n\t * @returns {L.MarkerClusterGroup.LayerSupport} this.\n\t */\n\tcheckOut: function (layers) {\n\t\tvar layersArray = this._toArray(layers),\n\t\t    separated = this._separateSingleFromGroupLayers(layersArray, {\n\t\t        groups: [],\n\t\t        singles: []\n\t\t    }),\n\t\t    groups = separated.groups,\n\t\t    singles = separated.singles,\n\t\t    i, layer;\n\n\t\t// Un-stamp single layers.\n\t\tfor (i = 0; i < singles.length; i++) {\n\t\t\tlayer = singles[i];\n\t\t\tdelete this._layers[L.stamp(layer)];\n\t\t\tdelete layer._mcgLayerSupportGroup;\n\t\t}\n\n\t\t// Batch remove single layers from MCG.\n\t\t// Note: as for standard MCG, if single layers have been added to\n\t\t// another MCG in the meantime, their __parent will have changed,\n\t\t// so weird things would happen.\n\t\tthis._originalRemoveLayers(singles);\n\n\t\t// Dismiss Layer Groups.\n\t\tfor (i = 0; i < groups.length; i++) {\n\t\t\tlayer = groups[i];\n\t\t\tthis._dismissProxyLayerGroup(layer);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Checks in and adds an array of layers to this group.\n\t * Layer Groups are also added to the map to fire their event.\n\t * @param layers (L.Layer|L.Layer[]) single and/or group layers to be added.\n\t * @returns {L.MarkerClusterGroup.LayerSupport} this.\n\t */\n\taddLayers: function (layers) {\n\t\tvar layersArray = this._toArray(layers),\n\t\t    separated = this._checkInGetSeparated(layersArray),\n\t\t    groups = separated.groups,\n\t\t    i, group, id;\n\n\t\t// Batch add all single layers.\n\t\tthis._originalAddLayers(separated.singles);\n\n\t\t// Add Layer Groups to the map so that they are registered there and\n\t\t// the map fires 'layeradd' events for them as well.\n\t\tfor (i = 0; i < groups.length; i++) {\n\t\t\tgroup = groups[i];\n\t\t\tid = L.stamp(group);\n\t\t\tthis._proxyLayerGroups[id] = group;\n\t\t\tdelete this._proxyLayerGroupsNeedRemoving[id];\n\t\t\tif (this._map) {\n\t\t\t\tthis._map._originalAddLayer(group);\n\t\t\t}\n\t\t}\n\t},\n\taddLayer: function (layer) {\n\t\tthis._bufferSingleAddRemove(layer, \"addLayers\");\n\t\treturn this;\n\t},\n\t_originalAddLayer: L.MarkerClusterGroup.prototype.addLayer,\n\t_originalAddLayers: L.MarkerClusterGroup.prototype.addLayers,\n\n\t/**\n\t * Removes layers from this group but without check out.\n\t * Layer Groups are also removed from the map to fire their event.\n\t * @param layers (L.Layer|L.Layer[]) single and/or group layers to be removed.\n\t * @returns {L.MarkerClusterGroup.LayerSupport} this.\n\t */\n\tremoveLayers: function (layers) {\n\t\tvar layersArray = this._toArray(layers),\n\t\t    separated = this._separateSingleFromGroupLayers(layersArray, {\n\t\t        groups: [],\n\t\t        singles: []\n\t\t    }),\n\t\t    groups = separated.groups,\n\t\t    singles = separated.singles,\n\t\t    i = 0,\n\t\t    group, id;\n\n\t\t// Batch remove single layers from MCG.\n\t\tthis._originalRemoveLayers(singles);\n\n\t\t// Remove Layer Groups from the map so that they are un-registered\n\t\t// there and the map fires 'layerremove' events for them as well.\n\t\tfor (; i < groups.length; i++) {\n\t\t\tgroup = groups[i];\n\t\t\tid = L.stamp(group);\n\t\t\tdelete this._proxyLayerGroups[id];\n\t\t\tif (this._map) {\n\t\t\t\tthis._map._originalRemoveLayer(group);\n\t\t\t} else {\n\t\t\t\tthis._proxyLayerGroupsNeedRemoving[id] = group;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\tremoveLayer: function (layer) {\n\t\tthis._bufferSingleAddRemove(layer, \"removeLayers\");\n\t\treturn this;\n\t},\n\t_originalRemoveLayer: L.MarkerClusterGroup.prototype.removeLayer,\n\t_originalRemoveLayers: L.MarkerClusterGroup.prototype.removeLayers,\n\n\tonAdd: function (map) {\n\t\t// Replace the map addLayer and removeLayer methods to place the\n\t\t// switch agent that redirects layers when required.\n\t\tmap._originalAddLayer = map._originalAddLayer || map.addLayer;\n\t\tmap._originalRemoveLayer = map._originalRemoveLayer || map.removeLayer;\n\t\tL.extend(map, _layerSwitchMap);\n\n\t\t// As this plugin allows the Application to add layers on map, some\n\t\t// checked in layers might have been added already, whereas LayerSupport\n\t\t// did not have a chance to inject the switch agent in to the map\n\t\t// (if it was never added to map before). Therefore we need to\n\t\t// remove all checked in layers from map!\n\t\tvar toBeReAdded = this._removePreAddedLayers(map),\n\t\t    id, group, i;\n\n\t\t// Normal MCG onAdd.\n\t\tthis._originalOnAdd.call(this, map);\n\n\t\t// If layer Groups are added/removed from this group while it is not\n\t\t// on map, Control.Layers gets out of sync until this is added back.\n\n\t\t// Restore proxy Layer Groups that may have been added to this\n\t\t// group while it was off map.\n\t\tfor (id in this._proxyLayerGroups) {\n\t\t\tgroup = this._proxyLayerGroups[id];\n\t\t\tmap._originalAddLayer(group);\n\t\t}\n\n\t\t// Remove proxy Layer Groups that may have been removed from this\n\t\t// group while it was off map.\n\t\tfor (id in this._proxyLayerGroupsNeedRemoving) {\n\t\t\tgroup = this._proxyLayerGroupsNeedRemoving[id];\n\t\t\tmap._originalRemoveLayer(group);\n\t\t\tdelete this._proxyLayerGroupsNeedRemoving[id];\n\t\t}\n\n\t\t// Restore Layers.\n\t\tfor (i = 0; i < toBeReAdded.length; i++) {\n\t\t\tmap.addLayer(toBeReAdded[i]);\n\t\t}\n\t},\n\t_originalOnAdd: L.MarkerClusterGroup.prototype.onAdd,\n\n\t// Do not restore the original map methods when removing the group from it.\n\t// Leaving them as-is does not harm, whereas restoring the original ones\n\t// may kill the functionality of potential other LayerSupport groups on\n\t// the same map. Therefore we do not need to override onRemove.\n\n\t_bufferSingleAddRemove: function (layer, operationType) {\n\t\tvar duration = this.options.singleAddRemoveBufferDuration,\n\t\t    fn;\n\n\t\tif (duration > 0) {\n\t\t\tthis._singleAddRemoveBuffer.push({\n\t\t\t\ttype: operationType,\n\t\t\t\tlayer: layer\n\t\t\t});\n\n\t\t\tif (!this._singleAddRemoveBufferTimeout) {\n\t\t\t\tfn = L.bind(this._processSingleAddRemoveBuffer, this);\n\n\t\t\t\tthis._singleAddRemoveBufferTimeout = setTimeout(fn, duration);\n\t\t\t}\n\t\t} else { // If duration <= 0, process synchronously.\n\t\t\tthis[operationType](layer);\n\t\t}\n\t},\n\t_processSingleAddRemoveBuffer: function () {\n\t\t// For now, simply cut the processes at each operation change\n\t\t// (addLayers, removeLayers).\n\t\tvar singleAddRemoveBuffer = this._singleAddRemoveBuffer,\n\t\t    i = 0,\n\t\t    layersBuffer = [],\n\t\t    currentOperation,\n\t\t    currentOperationType;\n\n\t\tfor (; i < singleAddRemoveBuffer.length; i++) {\n\t\t\tcurrentOperation = singleAddRemoveBuffer[i];\n\t\t\tif (!currentOperationType) {\n\t\t\t\tcurrentOperationType = currentOperation.type;\n\t\t\t}\n\t\t\tif (currentOperation.type === currentOperationType) {\n\t\t\t\tlayersBuffer.push(currentOperation.layer);\n\t\t\t} else {\n\t\t\t\tthis[currentOperationType](layersBuffer);\n\t\t\t\tcurrentOperationType = currentOperation.type;\n\t\t\t\tlayersBuffer = [currentOperation.layer];\n\t\t\t}\n\t\t}\n\t\tthis[currentOperationType](layersBuffer);\n\t\tsingleAddRemoveBuffer.length = 0;\n\t\tclearTimeout(this._singleAddRemoveBufferTimeout);\n\t\tthis._singleAddRemoveBufferTimeout = null;\n\t},\n\n\t_checkInGetSeparated: function (layersArray) {\n\t\tvar separated = this._separateSingleFromGroupLayers(layersArray, {\n\t\t        groups: [],\n\t\t        singles: []\n\t\t    }),\n\t\t    groups = separated.groups,\n\t\t    singles = separated.singles,\n\t\t    i, layer;\n\n\t\t// Recruit Layer Groups.\n\t\t// If they do not already belong to this group, they will be\n\t\t// removed from map (together will all child layers).\n\t\tfor (i = 0; i < groups.length; i++) {\n\t\t\tlayer = groups[i];\n\t\t\tthis._recruitLayerGroupAsProxy(layer);\n\t\t}\n\n\t\t// Stamp single layers.\n\t\tfor (i = 0; i < singles.length; i++) {\n\t\t\tlayer = singles[i];\n\n\t\t\t// Remove from previous group first.\n\t\t\tthis._removeFromOtherGroupsOrMap(layer);\n\n\t\t\tthis._layers[L.stamp(layer)] = layer;\n\t\t\tlayer._mcgLayerSupportGroup = this;\n\t\t}\n\n\t\treturn separated;\n\t},\n\n\t_separateSingleFromGroupLayers: function (inputLayers, output) {\n\t\tvar groups = output.groups,\n\t\t    singles = output.singles,\n\t\t    isArray = L.Util.isArray,\n\t\t    layer;\n\n\t\tfor (var i = 0; i < inputLayers.length; i++) {\n\t\t\tlayer = inputLayers[i];\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\tgroups.push(layer);\n\t\t\t\tthis._separateSingleFromGroupLayers(layer.getLayers(), output);\n\t\t\t\tcontinue;\n\t\t\t} else if (isArray(layer)) {\n\t\t\t\tthis._separateSingleFromGroupLayers(layer, output);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsingles.push(layer);\n\t\t}\n\n\t\treturn output;\n\t},\n\n\t// Recruit the LayerGroup as a proxy, so that any layer that is added\n\t// to / removed from that group later on is also added to / removed from\n\t// this group.\n\t// Check in and addition of already contained markers must be taken care\n\t// of externally.\n\t_recruitLayerGroupAsProxy: function (layerGroup) {\n\t\tvar otherMcgLayerSupportGroup = layerGroup._proxyMcgLayerSupportGroup;\n\n\t\t// If it is not yet in this group, remove it from previous group\n\t\t// or from map.\n\t\tif (otherMcgLayerSupportGroup) {\n\t\t\tif (otherMcgLayerSupportGroup === this) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Remove from previous Layer Support group first.\n\t\t\t// It will also be removed from map with child layers.\n\t\t\totherMcgLayerSupportGroup.checkOut(layerGroup);\n\t\t} else {\n\t\t\tthis._removeFromOwnMap(layerGroup);\n\t\t}\n\n\t\tlayerGroup._proxyMcgLayerSupportGroup = this;\n\t\tlayerGroup._originalAddLayer =\n\t\t\tlayerGroup._originalAddLayer || layerGroup.addLayer;\n\t\tlayerGroup._originalRemoveLayer =\n\t\t\tlayerGroup._originalRemoveLayer || layerGroup.removeLayer;\n\t\tL.extend(layerGroup, _proxyLayerGroup);\n\t},\n\n\t// Restore the normal LayerGroup behaviour.\n\t// Removal and check out of contained markers must be taken care of externally.\n\t_dismissProxyLayerGroup: function (layerGroup) {\n\t\tif (layerGroup._proxyMcgLayerSupportGroup === undefined ||\n\t\t\tlayerGroup._proxyMcgLayerSupportGroup !== this) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tdelete layerGroup._proxyMcgLayerSupportGroup;\n\t\tlayerGroup.addLayer = layerGroup._originalAddLayer;\n\t\tlayerGroup.removeLayer = layerGroup._originalRemoveLayer;\n\n\t\tvar id = L.stamp(layerGroup);\n\t\tdelete this._proxyLayerGroups[id];\n\t\tdelete this._proxyLayerGroupsNeedRemoving[id];\n\n\t\tthis._removeFromOwnMap(layerGroup);\n\t},\n\n\t_removeFromOtherGroupsOrMap: function (layer) {\n\t\tvar otherMcgLayerSupportGroup = layer._mcgLayerSupportGroup;\n\n\t\tif (otherMcgLayerSupportGroup) { // It is a Layer Support group.\n\t\t\tif (otherMcgLayerSupportGroup === this) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\totherMcgLayerSupportGroup.checkOut(layer);\n\n\t\t} else if (layer.__parent) { // It is in a normal MCG.\n\t\t\tlayer.__parent._group.removeLayer(layer);\n\n\t\t} else { // It could still be on a map.\n\t\t\tthis._removeFromOwnMap(layer);\n\t\t}\n\t},\n\n\t// Remove layers that are being checked in, because they can now cluster.\n\t_removeFromOwnMap: function (layer) {\n\t\tif (layer._map) {\n\t\t\t// This correctly fires layerremove event for Layer Groups as well.\n\t\t\tlayer._map.removeLayer(layer);\n\t\t}\n\t},\n\n\t// In case checked in layers have been added to map whereas map is not redirected.\n\t_removePreAddedLayers: function (map) {\n\t\tvar layers = this._layers,\n\t\t    toBeReAdded = [],\n\t\t    layer;\n\n\t\tfor (var id in layers) {\n\t\t\tlayer = layers[id];\n\t\t\tif (layer._map) {\n\t\t\t\ttoBeReAdded.push(layer);\n\t\t\t\tmap._originalRemoveLayer(layer);\n\t\t\t}\n\t\t}\n\n\t\treturn toBeReAdded;\n\t},\n\n\t_toArray: function (item) {\n\t\treturn L.Util.isArray(item) ? item : [item];\n\t}\n\n});\n\n/**\n * Extends the FeatureGroup by overriding add/removal methods that directly\n * access the map original methods, bypassing the switch agent.\n * Used internally in Layer Support for _featureGroup and _nonPointGroup only.\n * @type {L.FeatureGroup}\n * @private\n */\nvar _ByPassingFeatureGroup = L.FeatureGroup.extend({\n\n\t// Re-implement just to change the map method.\n\taddLayer: function (layer) {\n\t\tif (this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlayer.addEventParent(this);\n\n\t\tvar id = L.stamp(layer);\n\n\t\tthis._layers[id] = layer;\n\n\t\tif (this._map) {\n\t\t\t// Use the original map addLayer.\n\t\t\tthis._map._originalAddLayer(layer);\n\t\t}\n\n\t\treturn this.fire('layeradd', {layer: layer});\n\t},\n\n\t// Re-implement just to change the map method.\n\tremoveLayer: function (layer) {\n\t\tif (!this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\t\tif (layer in this._layers) {\n\t\t\tlayer = this._layers[layer];\n\t\t}\n\n\t\tlayer.removeEventParent(this);\n\n\t\tvar id = L.stamp(layer);\n\n\t\tif (this._map && this._layers[id]) {\n\t\t\t// Use the original map removeLayer.\n\t\t\tthis._map._originalRemoveLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this.fire('layerremove', {layer: layer});\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\t\t// Use the original map addLayer.\n\t\tthis.eachLayer(map._originalAddLayer, map);\n\t},\n\n\tonRemove: function (map) {\n\t\t// Use the original map removeLayer.\n\t\tthis.eachLayer(map._originalRemoveLayer, map);\n\t\tthis._map = null;\n\t}\n\n});\n\n/**\n * Toolbox to equip LayerGroups recruited as proxy.\n * @type {{addLayer: Function, removeLayer: Function}}\n * @private\n */\nvar _proxyLayerGroup = {\n\n\t// Re-implement to redirect addLayer to Layer Support group instead of map.\n\taddLayer: function (layer) {\n\t\tvar id = this.getLayerId(layer);\n\n\t\tthis._layers[id] = layer;\n\n\t\tif (this._map) {\n\t\t\tthis._proxyMcgLayerSupportGroup.addLayer(layer);\n\t\t} else {\n\t\t\tthis._proxyMcgLayerSupportGroup.checkIn(layer);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t// Re-implement to redirect removeLayer to Layer Support group instead of map.\n\tremoveLayer: function (layer) {\n\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tthis._proxyMcgLayerSupportGroup.removeLayer(layer);\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\t// Make sure it uses addLayers when added to map.\n\tonAdd: function () {\n\t\tthis._proxyMcgLayerSupportGroup.addLayers(this.getLayers());\n\t},\n\n\t// Make sure it uses removeLayers when removed from map.\n\tonRemove: function () {\n\t\tthis._proxyMcgLayerSupportGroup.removeLayers(this.getLayers());\n\t}\n\n};\n\n/**\n * Toolbox to equip the Map with a switch agent that redirects layers\n * addition/removal to their Layer Support group when defined.\n * @type {{addLayer: Function, removeLayer: Function}}\n * @private\n */\nvar _layerSwitchMap = {\n\n\taddLayer: function (layer) {\n\t\tif (layer._mcgLayerSupportGroup) {\n\t\t\t// Use the original MCG addLayer.\n\t\t\treturn layer._mcgLayerSupportGroup._originalAddLayer(layer);\n\t\t}\n\n\t\treturn this._originalAddLayer(layer);\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tif (layer._mcgLayerSupportGroup) {\n\t\t\t// Use the original MCG removeLayer.\n\t\t\treturn layer._mcgLayerSupportGroup._originalRemoveLayer(layer);\n\t\t}\n\n\t\treturn this._originalRemoveLayer(layer);\n\t}\n\n};\n\n// Supply with a factory for consistency with Leaflet.\nL.markerClusterGroup.layerSupport = function (options) {\n\treturn new L.MarkerClusterGroup.LayerSupport(options);\n};\n\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,;;"}