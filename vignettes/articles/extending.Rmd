---
title: "Extending Leaflet"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The Leaflet JavaScript library has a plethora of [plugins](https://leafletjs.com/plugins) available that extend the functionality of the core package. We have incorporated a chosen few in the R package. It may be desirable to use plugins available outside of what are supported by this package.

The way to achieve that is by extending the Leaflet package. By extending we mean writing your own code/package that incorporate your desired leaflet plugins and hook into the leaflet package.

# Functions for extending leaflet

Certain functions have been made available for you to use in your code while extending Leaflet.

## derivePoints/derivePolygons

`derivePoints()` and `derivePolygons()` can be used to extract point or shape (polygon/line/circle/rectangle) data from a `data.frame` or a spatial object from the `{sf}` package. It tries to auto determine the latitude/longitude colnames if not specified or use user supplied column mappings.

## evalFormula

`evalFormula()` is used to evaluate a formula on a given data and return the results. e.g., `leaflet(some.data.frame) %>% addMarkers(label=~name)` internally uses `evalFormula()` to calculate the correct label values from the data using the `~name` formula.

## expandLimits

You can call `expandLimits()` to make sure that your map's view is  just enough to show every point/shape in your data. This way you don't have to determine the exact bounds for your map.

## filterNULL

Often when passing a list from R to JavaScript it is desirable to remove any null elements, and that's exactly what `filterNULL()` does.

## getMapData

`getMapData()` accesses the data object passed when calling `leaflet()` function.

## invokeMethod

`invokeMethod()` is the glue between the R code and JavaScript code. Requires a corresponding method on the JavaScript side.

# Example

Here is a small example which shows how you can integrate heatmap functionality using a [plugin](https://leaflet.github.io/Leaflet.heat/). 

There are four key steps to add this plugin to a Leaflet map in R:

1. Define a function that takes a `htmltools::htmlDependency()` object and adds it to the map. This ensures that however or whenever the map gets rendered, the plugin will be loaded into the browser.

2. Actually create the `htmltools::htmlDependency()`. This function tells the browser our plugin name, version, and where to find the script. There's also a stylesheet argument if the plugin comes with CSS files.

3. Use our `registerPlugin()` function to register the plugin dependency with the `leaflet()` object. As the first argument of our function is `map`, this can be achieved as part of a pipeline.

4. We need to tell `Leaflet` what to actually *do* with our new plugin using `htmlwidgets::onRender()`. This adds additional rendering logic to this specific widget, written in JavaScript. Note that, in the below example, `this` refers to the `Leaflet` (JS) map object itself.

```{r, fig.height=4}
library(leaflet)
library(htmltools)
library(htmlwidgets)

# function to register plugin
registerPlugin <- function(map, plugin) {
  map$dependencies <- c(map$dependencies, list(plugin))
  map
}

# define plugin as a HTML dependency
heatPlugin <- htmlDependency(
  "Leaflet.heat",
  "0.2.0",
  src = c(href = "http://leaflet.github.io/Leaflet.heat/dist/"),
  script = "leaflet-heat.js"
)

# initialise leaflet map in R
leaflet() %>%
  addTiles() %>%
  fitBounds(min(quakes$long), min(quakes$lat), max(quakes$long), max(quakes$lat)) %>%
  # Register heatmap plugin on this map instance
  registerPlugin(heatPlugin) %>%
  # Add custom JS logic
  onRender("function(el, x, data) {
    data = HTMLWidgets.dataframeToD3(data);
    data = data.map(function(val) { return [val.lat, val.long, val.mag*100]; });
    L.heatLayer(data, {radius: 25}).addTo(this);
  }", data = quakes[c("lat", "long", "mag")])
```

